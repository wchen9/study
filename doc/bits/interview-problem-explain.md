# 一次内存泄漏问题的排查

> 笔记汇编自石杉的架构笔记公众号。

某天我们收到了服务器物理内存16G占用超过80%的告警，像是Java进程发生了内存泄漏，而我们的堆内存配置的最大值是4G，但是现在占用大于4G，像是堆外内存泄漏。当天我们没有更新服务端的代码，但是对接了一个新的系统，这个系统会大量调用我们系统的一个接口。这个接口我们平时的调用量大概在每分钟200次左右，接入进来后的调用量大概在5000次每分钟。

虽然一开始就认为不太可能是堆内存泄漏，但是保险起见，还是看了下堆内存能不能查到什么原因。我们观察了一下新生代跟老年代内存占用曲线和回收次数，跟往常一样。然后在事故服务器上面用jmap命令dump了一份JVM堆内存的日志。然后用JVisualVM打开日志文件看了下。然后观察到堆内存里面有一些nio有关的大对象，怀疑是客户端对nio使用不当，导致ByteBuffer使用了过多的直接内存。

然后我们在测试环境做了重现，继续用大量数据调用接口，然后观察内存占用。然后开始调用后内存占用就持续增长，看起来没有被限制住，于是我们怀疑是JVM没有对直接内存大小进行限制。但是加了参数-XX:MaxDirectMemorySize之后，继续重现，发现问题依然存在，所以我们排除了直接内存泄漏的选项。

然后我们怀疑是元空间内存泄漏，然后我们用jmap命令查询了一下生产的实际JVM配置，发现MaxMetaspaceSize基本上等于物理内存空间，看了一下JVM的启动参数，发现用的还是JDK 1.7的配置，MaxPermSize，也就是永久代的内存空间。所以实际上我们线上的配置是根本就没有做限制的。

然后我们添加了XX:MaxMetaspaceSize参数后，使用JVisualVM观察进程运行后，发现之前出现的内存泄漏问题没有了。于是可以确定是元空间参数没限制导致的问题。

然后我们排查接口为什么会重复调用导致元空间爆炸。我们在JVM启动参数上添加了-verbose:class，然后发现生成了无数的.class，然后加载到了元空间。我们发现是我们用到的fastjson的一个功能，将驼峰格式转换成下划线格式的字段，用到了SerializeConfig，如果我们复用SerializeConfig，fastjson就会寻找已经创建好的代理类，但是如果我们new SerializeConfig的话，就会生成一个新的DTO代理类。因为SerializeConfig 里面使用了ASM字节码增强技术，每次调用都会生成一个新的代理类，于是导致元空间占用内存不断膨胀，最后导致了问题。解决方法是将SerializeConfig 作为类的静态变量。

引申问题：为什么JDK1.7没有这个问题而JDK1.8出现了？

metaspace 默认的是整个机器的物理内存大小，所以metaspace不断扩张可能会导致物理内存最终耗尽。而永久区有默认大小，不会占用系统的整个物理内存。区别在于JDK1.7在FullGC时，用类似回收堆内存而机制去回收永久代的内存，只要跟引用不可达就回收掉了。而metaspace回收是判断加载类元数据的ClassLoader是否可以回收判断的。只要ClassLoader不能回收，那么其加载的类元数据也不能回收。

## 参考
- [1] [一次完整的JVM堆外内存泄漏故障排查记录](https://mp.weixin.qq.com/s/7x0eLMV8dnkuGpx1dJ9pBg)
